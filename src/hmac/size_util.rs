use crate::sha256::sha256;

/// Normalize a key to the correct block size (64 bytes for SHA-256).
///
/// # Arguments
/// - `k`: Key as a byte slice (`&[u8]`).
///
/// # Description
/// - If the key length is equal to the block size, it is returned unchanged.  
/// - If the key is longer, it is first hashed with SHA-256 and then padded 
///   with zeros.  
/// - If the key is shorter, zeros are appended until the block size is reached.  
///
/// # Returns
/// A vector of bytes (`Vec<u8>`) representing the normalized key (`K0`).
pub fn get_right_block_size(k: &[u8]) -> Vec<u8> {
    let mut k0: Vec<u8> = k.to_vec();
    let mut key_length = k0.len();
    let block_size = 64;
    
    // k = k0 if key length == block_size.
    if key_length == block_size {
        return k0;
    };
    
    // Hash k0 and append 0s if key_length > block_size.
    if key_length > block_size {
        k0 = sha256(&k0).to_vec();
        let mut k_l = k0.len();
        while k_l < block_size {
            k0.push(0x00);
            k_l += 1;
        };
    };

    // Append all 0s if key_length < block_size.
    if key_length < block_size {
        let mut k_l = k.len();
        while k_l < block_size {
            k0.push(0x00);
            k_l += 1;
        };
    };

    k0
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn computes_k_as_k0_since_k_length_is_block_length() {
        let k = [
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        ];

        let k0 = k;

        let result = get_right_block_size(&k0);
        let expected = k0;

        assert_eq!((result), (expected));
    }

    #[test]
    fn computes_block_back_to_sha256_size_append_0s_then_assign_as_k0() {
        let k = b"a".repeat(1_000_000);
        let k0 = [
            0xcd, 0xc7, 0x6e, 0x5c, 0x99, 0x14, 0xfb, 0x92, 
            0x81, 0xa1, 0xc7, 0xe2, 0x84, 0xd7, 0x3e, 0x67, 
            0xf1, 0x80, 0x9a, 0x48, 0xa4, 0x97, 0x20, 0x0e, 
            0x04, 0x6d, 0x39, 0xcc, 0xc7, 0x11, 0x2c, 0xd0,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let result = get_right_block_size(&k);
        let expected = k0;

        assert_eq!((result), (expected));
    }

    #[test]
    fn computes_key_to_k0_and_appends_all_0s() {
        let k = b"abc";
        let k0 = [
            0x61, 0x62, 0x63, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        ];

        let result = get_right_block_size(k);
        let expected = k0;

        assert_eq!((result), (expected));
    }
}